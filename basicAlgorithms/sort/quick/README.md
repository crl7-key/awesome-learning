# Quick_sort

快速排序是一种**交换排序**,是对冒泡排序的一种改进,它由`C. A. R. Hoare`在`1962`年提出。

算法思想:通过一趟排序将要排序的数据分割成独立的两部分：**分割点左边都是比它小的数,右边都是比它大的数**。  
 
然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。  
核心就是**找到基准值的位置**。

## 快速排序步骤:
- 选择一个值作为基准值
- 找到基准值的位置,并将小于基准值的元素放在基准值的前面(左边), 大于基准值的元素放在基准值的后面(右边)
- 递归(recursive)地将小于基准值元素的子序列和大于基准值元素的子序列排序。

例如：
有这样一组数 `{8, 3, 10, 2, 7, 6, 9, 12 }`,第一步就是**选择一个值作为基准值**。最简单的选择方法,一定是选择待排序区间的头部元素作为基准值。
- 第一步:设置两个指针`left`和`right`,分别指向数组的头部(`8`)和尾部(`12`)。并且以头部元素(`8`)为基准数`base`。
```
本轮基准值 : 8
 0       1      2       3      4      5      6        7
 8       3      10      2      7      6      9       12   
 ｜                                                   |  
left                                                 right   
```

- 第二步:从`右至左`扫描,通过偏移`right`指针,寻找`比基准数小的元素`,找到比基准数小的元素`(6)`,将其赋值给`left`指针所指的位置。`right`的位置就相当于空出来一个位置
```
本轮基准值 : 8
 0       1      2       3      4      5      6        7
 6       3      10      2      7            9        12   
 ｜                                   |               
left                                 right              
```

- 第三步: 从`左至右`扫描,通过偏移`left`指针,寻找`比基准数大的元素`,找到比基准数大的元素`(10)`,将其赋值给`right`指针所指的位置。`left`的位置就相当于空出一个位置
```
本轮基准值 : 8
 0       1      2       3      4      5      6        7
 6       3              2      7     10       9        12   
                ｜                    |               
               left                  right      
```

- 第四步: 不断重复第二步、第三步,直到`left`、`right`指针重合。这样，所有的元素都被扫描了一遍。然后将基准数(`8)`赋值给重合的位置,此时已完成了一次排序,基准数(`8`)左边都是比它小的数、右边都是比它大的数。
```
本轮基准值 : 8  
 0       1      2       3      4      5      6        7
 6       3      7       2      8      10     9        12   
                               |                     
                            left、right                 
```
- 第五步:以基准数(`8`)为分割点。对其左侧和右侧的数分别按照一、二、三、四步骤去进行排序.经过`递归`过程.最后排序结束.也就是说分别对`6、3、7、2`和`10、9、12`这两部分再做选择基准值、找基准值的正确位置和递归这三步。由于每次`partition`操作中,我们都会确定一个值,也就是基准值的正确位置,所以,经过有限次递归操作以后,整个数组也就变成了一个有序数组。

```c++
template<class T>
int partition(T arr[],int left,int right) {
    // 以最左边的数(left)为基准
    int base = arr[left];
    while (left < right) {
        // 从序列右端开始,向左遍历,直到找到小于base的数
        while (left < right && arr[right] >= base)
            right--;
        // 找到了比base小的元素,将这个元素放到最左边的位置
        arr[left] = arr[right];
 
        // 从序列左端开始,向右遍历,直到找到大于base的数
        while (left < right && arr[left] <= base)
            left++;
        // 找到了比base大的元素,将这个元素放到最右边的位置
        arr[right] = arr[left];
    }
 
    // 最后将base放到left位置。此时,left位置的左侧数值应该都比left小；
    // 而left位置的右侧数值应该都比left大。
    arr[left] = base;
    return left;
}


template<class T>
void quickSort(T arr[],int left,int right) {
    if (left < right) {  // 左下标一定小于右下标，否则就会越界
        // 对数组进行分割，取出下次分割的基准标号
        int base = partition(arr, left, right);

        // 对“基准标号“左侧的一组数值进行递归的切割，以至于将这些数值完整的排序
        quickSort(arr,left,base - 1);

        // 对“基准标号“右侧的一组数值进行递归的切割，以至于将这些数值完整的排序
        quickSort(arr,base + 1,right);
    }
}
```
