# C++设计模式之建造者模式

## 目录
* [什么是建造者模式？](#什么是建造者模式？)
* [建造者模式角色](#建造者模式角色)
    - [指挥者Director](#指挥者Director)
    - [建造者Builder](#建造者Builder)
    - [产品类Product](#产品类Product)
* [建造者模式的优缺点](#建造者模式的优缺点)
* [建造者模式使用场景](#建造者模式使用场景)

## 什么是建造者模式？
建造者模式也称生成器模式,将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。即使外部只需要提供产品需要的各个零件,将这些零部件提供给建造者,有一个指挥家会指挥建造者一步步组装成产品,外部不需要知道具体构建细节就可以直接获取产品。  

建造者模式和抽象工厂模式在功能上很相似,都是用来创建大的复杂的对象,区别是：建造者模式强调的是**一步步创建对象,并通过相同的创建过程可以获得不同的结果对象,一般来说建造者模式中对象不是直接返回的**。而在抽象工厂模式中对象是直接返回的，抽象工厂模式强调的是为创建多个相互依赖的对象提供一个同一的接口。  

建造者模式最主要功能是基本方法的调用顺序安排，即对象的组装顺序，而工厂方法则重点是创建，要什么对象创造一个对象出来，组装顺序则不是他关心的。  

 建造者模式的特点:
 - 将一个复杂对象的创建过程给封装起来,客户只需要知道可以利用对象名或者类型就能够得到一个完整的对象实例,而不需要关心对象的具体创建过程。
 - 将对象的创建过程与对象本身隔离开了,使得细节依赖于抽象,符合依赖倒置原则。可以使用相同的创建过程来创建不同的产品对象。

## 建造者模式角色

### 指挥者Director
指挥者`Director`: 构建一个使用`AbstractBuilder`对象的接口,`Construct`函数通过调用具体建造者的接口函数完成对象的构建（各个不同部分装配的过程都是一致的,但不同的构建方式会有不同的表示(根据`AbstractBuilder`的实际类型来决定如何构建,也就是多态)。指挥者角色的作用是隔离了客户与对象的生产过程并负责控制产品对象的生产过程。指挥者负责调用适当的建造者来组建产品，一般不与产品类发生依赖关系，与指挥者类直接交互的是建造者类。一般来说,指挥者列被用来封装程序中易变的部分。
```c++
class Director {
public:
    Director(AbstractBuilder* builder) {
        this->builder = builder;
    }

    ~Director() {}

    Product* Construct() {
        this->builder->BuildFirst();
        this->builder->BuildSecond();
        this->builder->BuildThird();
        return this->builder->GetProduct();
    }
private:
    AbstractBuilder* builder;
};
```
可以看到上述代码,作为指挥家,一方面隔离产品的创建过程,一方面控制产品的创建步骤.外部只需要知道具体建造者的类型,指挥家就可以调用建造者的相应方法去构建,外部就可以获取一个完整的产品对象。


### 建造者Builder
建造者`AbstractBuilder`：定义创建对象过程的抽象,提供构建不同组成部分的接口,`BuildFirst()`,`BuildSecond()`,`BuildThird()`是对一个对象不同部分的构建函数接口,由`Builder`的派生类`ConcreteBuilderM`、`ConcreteBuilderN`来具体实现。组建产品；返回组建好的产品。

```c++
class AbstractBuilder {
public:
    AbstractBuilder() {}
    virtual ~AbstractBuilder() {}

    virtual void BuildFirst() = 0;
    virtual void BuildSecond() = 0;
    virtual void BuildThird() = 0;
    virtual Product* GetProduct() = 0;
};
```

### 产品类Product
产品类`Product`: 一般是一个较为复杂的对象,即创建对象的过程比较复杂,一般会有比较多的代码量。实际编程中,产品类可以是由一个抽象类及其不同实现组成,也可以是由多个抽象类及其实现组成。

```c++
class Product {
public:
    void SetPartFirst(int value) {
        this->first = value;
        flag[0] = true;
    }

    void SetPartSecond(int value) {
        if (!flag[0]) return;
        this->second = value;
        flag[1] = true;
    }

    void SetPartThird(int value) {
        if (!flag[0] || !flag[1]) return;
        this->third = value;
        flag[2] = true;
    }

    bool IsOk() {
        return flag[0] && flag[1] && flag[2];
    }
private:
    std::array<bool,3> flag;
    int first;
    int second;
    int third;
};
```
一个对象可能有不同的组成部分,不同部分的创建在创建对象会有不同的表示，但各个部分之间装配的方式是一致的,`Director::Construct`函数中固定了各个组成部分的装配方式,当具体是装配怎样的组成部分由`AbstractBuilder`的派生类`ConcreteBuilder`实现。

## 建造者模式的优缺点
优点：
- 建造者模式的封装性很好。使用建造者模式可以有效的封装变化,在使用建造者模式的场景中,一般产品类和建造者类是比较稳定的,因此,将主要的业务逻辑封装在指挥者类中对整体而言可以取得比较好的稳定性。
- 建造者模式很容易进行扩展。如果有新的需求,通过实现一个新的建造者类就可以完成,基本上不用修改之前已经测试通过的代码,因此也就不会对原有功能引入风险。   
- 将复杂产品的创建步骤分解在不同的方法中,使得创建过程更加清晰,使得我们能够更加精确的控制复杂对象的产生过程。   
- 将产品的创建过程与产品本身分离开来,可以使用相同的创建过程来得到不同的产品。   
- 每一个具体建造者都相对独立,而与其他的具体建造者无关,因此可以很方便地替换具体建造者或增加新的具体建造者,用户使用不同的具体建造者即可得到不同的产品对象。   

缺点:
- 要求构建产品的步骤（算法）是不能剧烈变化的,最好是不变的,影响了灵活度。
- 如果产品的内部变化复杂,可能会导致需要定义很多具体建造者类来实现内部复杂的变化,导致系统变得很庞大。

### 建造者模式使用场景
建造者模式使用场景：
- 建造者模式所创建的产品一般具有较多的共同点,其组成部分相似,如果产品之间的差异性很大,则不适合使用建造者模式,因此其使用范围受到一定的限制。
- 当创建复杂对象的算法应该独立于对象的组成部分以及装配方式时。
- 当构造过程必须允许被构造的对象各部分有不同的表示时。
- 需要生成的产品对象有复杂的内部结构，产品对象通常包含多个成员属性。


具体实现可看代码:
**[builder](contains.cpp)**<br>


**[⬆ 返回顶部](#目录)**