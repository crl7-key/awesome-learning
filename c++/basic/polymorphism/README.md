# C++ polymorphism


## 目录
* [多态的介绍](#多态的介绍)
* [动态多态和静态动态](#动态多态和静态动态)
* [产生动态多态的条件](#产生动态多态的条件)
* [多态需要注意的地方](#多态需要注意的地方)

### 多态的介绍
多态:**是面向对象程序设计语言中数据抽象和继承之外的第三个基本特征** ,可以简单地概括为 **“一个接口，多种方法”**.即指相同对象收到不同消息或不同对象收到相同消息时产生不同的实现动作。   

### 动态多态和静态动态
C++运行时多态性是通过虚函数(`virtual`)来实现的,虚函数允许派生类重新定义成员函数,而派生类重新定义基类的做法称为覆盖(`Override`),或者称为重写。    

多态与非多态的实质区别就是**函数地址是早绑定还是晚绑定**。    

编译时多态性（静态多态）：如果函数的调用,在编译器编译期间就可以确定函数的调用地址,并生产代码,是静态的,就是说地址是早绑定的。例如调用函数被编译器设置为基类中的版本。   

运行时多态性（动态多态）：通过虚函数实现,如果函数调用的地址不能在编译器期间确定,需要在运行时才确定,这就属于晚绑定。  

如果两个类有继承关系,赋值时不需要强制类型转换。  

### 产生动态多态的条件
- 必须有继承关系,赋值是不需要强制类型转换  
- 基类中必须有虚函数（虚函数: 就是在函数前面加`virtual`关键字)   
- 派生类必须重写基类的虚函数  
    - 重写：派生类继承基类,派生类重新定义基类的实现,函数的返回值,函数名,函数的参数一致,函数的内容可以不一样
- 在使用时基类的引用或指针指向派生类的对象
```c++
    Derived derived;      // 派生类对象
    
    Base* p = &derived;   // 父类指针指向子类对象，多态实现，动态绑定
    p->foo();             // 调用派生类同名函数
```

**父类的指针如何找到调用的函数 ？**     

先找到虚函数表指针,这个虚函数表指针指向了虚函数表,这个表中有需要调用函数的地址,找到这个地址然后进行调用。  


### 多态需要注意的地方
- 只有类的成员函数才能声明为虚函数,虚函数仅适用于有继承关系的类对象。普通函数不能声明为虚函数。
- 静态成员函数不能是虚函数，因为静态成员函数不受限于某个对象。
- 内联函数（`inline`）不能是虚函数，因为内联函数不能在运行中动态确定位置。
- 构造函数不能是虚函数。
- 析构函数可以是虚函数，而且建议声明为虚函数。


**[⬆ 返回顶部](#目录)**